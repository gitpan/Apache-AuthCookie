.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Apache2::AuthCookie 3"
.TH Apache2::AuthCookie 3 "2009-10-26" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
Apache2::AuthCookie \- Perl Authentication and Authorization via cookies
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Make sure your mod_perl is at least 1.24, with StackedHandlers,
MethodHandlers, Authen, and Authz compiled in.
.PP
.Vb 4
\& # In httpd.conf or .htaccess:
\& PerlModule Sample::AuthCookieHandler
\& PerlSetVar WhatEverPath /
\& PerlSetVar WhatEverLoginScript /login.pl
.Ve
.PP
.Vb 6
\& # use to alter how "require" directives are matched. Can be "Any" or "All".
\& # If its "Any", then you must only match Any of the "require" directives. If
\& # its "All", then you must match All of the require directives. 
\& #
\& # Default: All
\& PerlSetVar WhatEverSatisfy Any
.Ve
.PP
.Vb 3
\& # The following line is optional - it allows you to set the domain
\& # scope of your cookie.  Default is the current domain.
\& PerlSetVar WhatEverDomain .yourdomain.com
.Ve
.PP
.Vb 2
\& # Use this to only send over a secure connection
\& PerlSetVar WhatEverSecure 1
.Ve
.PP
.Vb 5
\& # Use this if you want user session cookies to expire if the user
\& # doesn't request a auth-required or recognize_user page for some
\& # time period.  If set, a new cookie (with updated expire time)
\& # is set on every request.
\& PerlSetVar WhatEverSessionTimeout +30m
.Ve
.PP
.Vb 4
\& # to enable the HttpOnly cookie property, use HttpOnly.
\& # this is an MS extension.  See:
\& # http://msdn.microsoft.com/workshop/author/dhtml/httponly_cookies.asp
\& PerlSetVar WhatEverHttpOnly 1
.Ve
.PP
.Vb 2
\& # Usually documents are uncached - turn off here
\& PerlSetVar WhatEverCache 1
.Ve
.PP
.Vb 2
\& # Use this to make your cookies persistent (+2 hours here)
\& PerlSetVar WhatEverExpires +2h
.Ve
.PP
.Vb 4
\& # Use to make AuthCookie send a P3P header with the cookie
\& # see http://www.w3.org/P3P/ for details about what the value 
\& # of this should be
\& PerlSetVar WhatEverP3P "CP=\e"...\e""
.Ve
.PP
.Vb 8
\& # These documents require user to be logged in.
\& <Location /protected>
\&  AuthType Sample::AuthCookieHandler
\&  AuthName WhatEver
\&  PerlAuthenHandler Sample::AuthCookieHandler->authenticate
\&  PerlAuthzHandler Sample::AuthCookieHandler->authorize
\&  require valid-user
\& </Location>
.Ve
.PP
.Vb 6
\& # These documents don't require logging in, but allow it.
\& <FilesMatch "\e.ok$">
\&  AuthType Sample::AuthCookieHandler
\&  AuthName WhatEver
\&  PerlFixupHandler Sample::AuthCookieHandler->recognize_user
\& </FilesMatch>
.Ve
.PP
.Vb 7
\& # This is the action of the login.pl script above.
\& <Files LOGIN>
\&  AuthType Sample::AuthCookieHandler
\&  AuthName WhatEver
\&  SetHandler perl-script
\&  PerlResponseHandler Sample::AuthCookieHandler->login
\& </Files>
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module is for mod_perl version 2.  If you are running mod_perl version 1,
you should be using \fBApache::AuthCookie\fR instead.
.PP
\&\fBApache2::AuthCookie\fR allows you to intercept a user's first
unauthenticated access to a protected document. The user will be
presented with a custom form where they can enter authentication
credentials. The credentials are posted to the server where AuthCookie
verifies them and returns a session key.
.PP
The session key is returned to the user's browser as a cookie. As a
cookie, the browser will pass the session key on every subsequent
accesses. AuthCookie will verify the session key and re-authenticate
the user.
.PP
All you have to do is write a custom module that inherits from
AuthCookie.  Your module is a class which implements two methods:
.ie n .IP """authen_cred()""" 4
.el .IP "\f(CWauthen_cred()\fR" 4
.IX Item "authen_cred()"
Verify the user-supplied credentials and return a session key.  The
session key can be any string \- often you'll use some string
containing username, timeout info, and any other information you need
to determine access to documents, and append a one-way hash of those
values together with some secret key.
.ie n .IP """authen_ses_key()""" 4
.el .IP "\f(CWauthen_ses_key()\fR" 4
.IX Item "authen_ses_key()"
Verify the session key (previously generated by \f(CW\*(C`authen_cred()\*(C'\fR,
possibly during a previous request) and return the user \s-1ID\s0.  This user
\&\s-1ID\s0 will be fed to \f(CW\*(C`$r\->user()\*(C'\fR to set Apache's idea of who's logged in.
.PP
By using AuthCookie versus Apache's built-in AuthBasic you can design
your own authentication system.  There are several benefits.
.IP "1." 4
The client doesn't *have* to pass the user credentials on every
subsequent access.  If you're using passwords, this means that the
password can be sent on the first request only, and subsequent
requests don't need to send this (potentially sensitive) information.
This is known as \*(L"ticket\-based\*(R" authentication.
.IP "2." 4
When you determine that the client should stop using the
credentials/session key, the server can tell the client to delete the
cookie.  Letting users \*(L"log out\*(R" is a notoriously impossible-to-solve
problem of AuthBasic.
.IP "3." 4
AuthBasic dialog boxes are ugly.  You can design your own \s-1HTML\s0 login
forms when you use AuthCookie.
.IP "4." 4
You can specify the domain of a cookie using PerlSetVar commands.  For
instance, if your AuthName is \f(CW\*(C`WhatEver\*(C'\fR, you can put the command 
.Sp
.Vb 1
\& PerlSetVar WhatEverDomain .yourhost.com
.Ve
.Sp
into your server setup file and your access cookies will span all
hosts ending in \f(CW\*(C`.yourhost.com\*(C'\fR.
.IP "5." 4
You can optionally specify the name of your cookie using the \f(CW\*(C`CookieName\*(C'\fR
directive.  For instance, if your AuthName is \f(CW\*(C`WhatEver\*(C'\fR, you can put the
command
.Sp
.Vb 1
\& PerlSetVar WhatEverCookieName MyCustomName
.Ve
.Sp
into your server setup file and your cookies for this AuthCookie realm will be
named MyCustomName.  Default is AuthType_AuthName.
.IP "6." 4
By default users must satisfy \s-1ALL\s0 of the \f(CW\*(C`require\*(C'\fR directives.  If you
want authentication to succeed if \s-1ANY\s0 \f(CW\*(C`require\*(C'\fR directives are met, use the
\&\f(CW\*(C`Satisfy\*(C'\fR directive.  For instance, if your AuthName is \f(CW\*(C`WhatEver\*(C'\fR, you can
put the command
.Sp
.Vb 1
\& PerlSetVar WhatEverSatisfy Any
.Ve
.Sp
into your server startup file and authentication for this realm will succeed if
\&\s-1ANY\s0 of the \f(CW\*(C`require\*(C'\fR directives are met.
.PP
This is the flow of the authentication handler, less the details of the
redirects. Two \s-1HTTP_MOVED_TEMPORARILY\s0's are used to keep the client from
displaying the user's credentials in the Location field. They don't really
change AuthCookie's model, but they do add another round-trip request to the
client.
.PP
.Vb 53
\& (-----------------------)     +---------------------------------+
\& ( Request a protected   )     | AuthCookie sets custom error    |
\& ( page, but user hasn't )---->| document and returns            |
\& ( authenticated (no     )     | HTTP_FORBIDDEN. Apache abandons |      
\& ( session key cookie)   )     | current request and creates sub |      
\& (-----------------------)     | request for the error document. |<-+
\&                               | Error document is a script that |  |
\&                               | generates a form where the user |  |
\&                 return        | enters authentication           |  |
\&          ^------------------->| credentials (login & password). |  |
\&         / \e      False        +---------------------------------+  |
\&        /   \e                                   |                   |
\&       /     \e                                  |                   |
\&      /       \e                                 V                   |
\&     /         \e               +---------------------------------+  |
\&    /   Pass    \e              | User's client submits this form |  |
\&   /   user's    \e             | to the LOGIN URL, which calls   |  |
\&   | credentials |<------------| AuthCookie->login().            |  |
\&   \e     to      /             +---------------------------------+  |
\&    \eauthen_cred/                                                   |
\&     \e function/                                                    |
\&      \e       /                                                     |
\&       \e     /                                                      |
\&        \e   /            +------------------------------------+     |
\&         \e /   return    | Authen cred returns a session      |  +--+
\&          V------------->| key which is opaque to AuthCookie.*|  |
\&                True     +------------------------------------+  |
\&                                              |                  |
\&               +--------------------+         |      +---------------+
\&               |                    |         |      | If we had a   |
\&               V                    |         V      | cookie, add   |
\&  +----------------------------+  r |         ^      | a Set-Cookie  |
\&  | If we didn't have a session|  e |T       / \e     | header to     |
\&  | key cookie, add a          |  t |r      /   \e    | override the  |
\&  | Set-Cookie header with this|  u |u     /     \e   | invalid cookie|
\&  | session key. Client then   |  r |e    /       \e  +---------------+
\&  | returns session key with   |  n |    /  pass   \e               ^    
\&  | successive requests        |    |   /  session  \e              |
\&  +----------------------------+    |  /   key to    \e    return   |
\&               |                    +-| authen_ses_key|------------+
\&               V                       \e             /     False
\&  +-----------------------------------+ \e           /
\&  | Tell Apache to set Expires header,|  \e         /
\&  | set user to user ID returned by   |   \e       /
\&  | authen_ses_key, set authentication|    \e     /
\&  | to our type (e.g. AuthCookie).    |     \e   /
\&  +-----------------------------------+      \e /
\&                                              V
\&         (---------------------)              ^
\&         ( Request a protected )              |
\&         ( page, user has a    )--------------+
\&         ( session key cookie  )
\&         (---------------------)
.Ve
.PP
.Vb 5
\& *  The session key that the client gets can be anything you want.  For
\&    example, encrypted information about the user, a hash of the
\&    username and password (similar in function to Digest
\&    authentication), or the user name and password in plain text
\&    (similar in function to HTTP Basic authentication).
.Ve
.PP
.Vb 3
\&    The only requirement is that the authen_ses_key function that you
\&    create must be able to determine if this session_key is valid and
\&    map it back to the originally authenticated user ID.
.Ve
.SH "METHODS"
.IX Header "METHODS"
\&\f(CW\*(C`Apache2::AuthCookie\*(C'\fR has several methods you should know about.  Here
is the documentation for each. =)
.IP "* \fIauthenticate()\fR" 4
.IX Item "authenticate()"
This method is one you'll use in a server config file (httpd.conf,
\&.htaccess, ...) as a PerlAuthenHandler.  If the user provided a
session key in a cookie, the \f(CW\*(C`authen_ses_key()\*(C'\fR method will get
called to check whether the key is valid.  If not, or if there is no
key provided, we redirect to the login form.
.IP "* \fIauthorize()\fR" 4
.IX Item "authorize()"
This will step through the \f(CW\*(C`require\*(C'\fR directives you've given for
protected documents and make sure the user passes muster.  The
\&\f(CW\*(C`require valid\-user\*(C'\fR and \f(CW\*(C`require user joey\-jojo\*(C'\fR directives are
handled for you.  You can implement custom directives, such as
\&\f(CW\*(C`require species hamster\*(C'\fR, by defining a method called \f(CW\*(C`species()\*(C'\fR
in your subclass, which will then be called.  The method will be
called as \f(CW\*(C`$r\->species($r, $args)\*(C'\fR, where \f(CW$args\fR is everything
on your \f(CW\*(C`require\*(C'\fR line after the word \f(CW\*(C`species\*(C'\fR.  The method should
return \s-1OK\s0 on success and \s-1HTTP_FORBIDDEN\s0 on failure.
.IP "* \fIauthen_cred()\fR" 4
.IX Item "authen_cred()"
You must define this method yourself in your subclass of
\&\f(CW\*(C`Apache2::AuthCookie\*(C'\fR.  Its job is to create the session key that will
be preserved in the user's cookie.  The arguments passed to it are:
.Sp
.Vb 4
\& sub authen_cred ($$\e@) {
\&   my $self = shift;  # Package name (same as AuthName directive)
\&   my $r    = shift;  # Apache request object
\&   my @cred = @_;     # Credentials from login form
.Ve
.Sp
.Vb 3
\&   ...blah blah blah, create a session key...
\&   return $session_key;
\& }
.Ve
.Sp
The only limitation on the session key is that you should be able to
look at it later and determine the user's username.  You are
responsible for implementing your own session key format.  A typical
format is to make a string that contains the username, an expiration
time, whatever else you need, and an \s-1MD5\s0 hash of all that data
together with a secret key.  The hash will ensure that the user
doesn't tamper with the session key.  More info in the Eagle book.
.IP "* \fIauthen_ses_key()\fR" 4
.IX Item "authen_ses_key()"
You must define this method yourself in your subclass of
Apache2::AuthCookie.  Its job is to look at a session key and determine
whether it is valid.  If so, it returns the username of the
authenticated user.
.Sp
.Vb 5
\& sub authen_ses_key ($$$) {
\&   my ($self, $r, $session_key) = @_;
\&   ...blah blah blah, check whether $session_key is valid...
\&   return $ok ? $username : undef;
\& }
.Ve
.Sp
Optionally, return an array of 2 or more items that will be passed to method
custom_errors. It is the responsibility of this method to return the correct
response to the main Apache module.
.IP "* custom_errors($r,@_)" 4
.IX Item "custom_errors($r,@_)"
Note: this interface is experimental.
.Sp
This method handles the server response when you wish to access the Apache
custom_response method. Any suitable response can be used. this is
particularly useful when implementing 'by directory' access control using
the user authentication information. i.e.
.Sp
.Vb 4
\&        /restricted
\&                /one            user is allowed access here
\&                /two            not here
\&                /three          AND here
.Ve
.Sp
The authen_ses_key method would return a normal response when the user attempts
to access 'one' or 'three' but return (\s-1NOT_FOUND\s0, 'File not found') if an
attempt was made to access subdirectory 'two'. Or, in the case of expired
credentials, (\s-1AUTH_REQUIRED\s0,'Your session has timed out, you must login
again').
.Sp
.Vb 1
\&  example 'custom_errors'
.Ve
.Sp
.Vb 6
\&  sub custom_errors {
\&    my ($self,$r,$CODE,$msg) = @_;
\&    # return custom message else use the server's standard message
\&    $r->custom_response($CODE, $msg) if $msg;
\&    return($CODE);
\&  }
.Ve
.Sp
.Vb 1
\&  where CODE is a valid code from Apache2::Const
.Ve
.IP "* \fIlogin()\fR" 4
.IX Item "login()"
This method handles the submission of the login form.  It will call
the \f(CW\*(C`authen_cred()\*(C'\fR method, passing it \f(CW$r\fR and all the submitted
data with names like \f(CW"credential_#"\fR, where # is a number.  These will
be passed in a simple array, so the prototype is
\&\f(CW\*(C`$self\->authen_cred($r, @credentials)\*(C'\fR.  After calling
\&\f(CW\*(C`authen_cred()\*(C'\fR, we set the user's cookie and redirect to the
\&\s-1URL\s0 contained in the \f(CW"destination"\fR submitted form field.
.IP "* login_form($r)" 4
.IX Item "login_form($r)"
This method is responsible for displaying the login form. The default
implementation will make an internal redirect and display the \s-1URL\s0 you
specified with the \f(CW\*(C`PerlSetVar WhatEverLoginScript\*(C'\fR configuration
directive. You can overwrite this method to provide your own
mechanism.
.IP "* \fIlogout()\fR" 4
.IX Item "logout()"
This is simply a convenience method that unsets the session key for
you.  You can call it in your logout scripts.  Usually this looks like
\&\f(CW\*(C`$r\->auth_type\->logout($r);\*(C'\fR.
.ie n .IP "* send_cookie($r, $session_key)" 4
.el .IP "* send_cookie($r, \f(CW$session_key\fR)" 4
.IX Item "send_cookie($r, $session_key)"
By default this method simply sends out the session key you give it.
If you need to change the default behavior (perhaps to update a
timestamp in the key) you can override this method.
.IP "* \fIrecognize_user()\fR" 4
.IX Item "recognize_user()"
If the user has provided a valid session key but the document isn't
protected, this method will set \f(CW\*(C`$r\->user\*(C'\fR
anyway.  Use it as a PerlFixupHandler, unless you have a better idea.
.IP "* key($r)" 4
.IX Item "key($r)"
This method will return the current session key, if any.  This can be
handy inside a method that implements a \f(CW\*(C`require\*(C'\fR directive check
(like the \f(CW\*(C`species\*(C'\fR method discussed above) if you put any extra
information like clearances or whatever into the session key.
.ie n .IP "* untaint_destination($self, $uri)" 4
.el .IP "* untaint_destination($self, \f(CW$uri\fR)" 4
.IX Item "untaint_destination($self, $uri)"
This method returns a modified version of the destination parameter
before embedding it into the response header. Per default it escapes
\&\s-1CR\s0, \s-1LF\s0 and \s-1TAB\s0 characters of the uri to avoid certain types of
security attacks. You can override it to more limit the allowed
destinations, e.g., only allow relative uris, only special hosts or
only limited set of characters.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
For an example of how to use Apache2::AuthCookie, you may want to check
out the test suite, which runs AuthCookie through a few of its paces.
The documents are located in t/eg/, and you may want to peruse
t/real.t to see the generated httpd.conf file (at the bottom of
real.t) and check out what requests it's making of the server (at the
top of real.t).
.SH "THE LOGIN SCRIPT"
.IX Header "THE LOGIN SCRIPT"
You will need to create a login script (called login.pl above) that
generates an \s-1HTML\s0 form for the user to fill out.  You might generate
the page using a ModPerl::Registry script, a HTML::Mason component, an Apache
handler, or perhaps even using a static \s-1HTML\s0 page.  It's usually useful to
generate it dynamically so that you can define the 'destination' field
correctly (see below).
.PP
The following fields must be present in the form:
.IP "1." 4
The \s-1ACTION\s0 of the form must be /LOGIN (or whatever you defined in your
server configuration as handled by the \->\fIlogin()\fR method \- see example
in the \s-1SYNOPSIS\s0 section).
.IP "2." 4
The various user input fields (username, passwords, etc.) must be
named 'credential_0', 'credential_1', etc. on the form.  These will
get passed to your \fIauthen_cred()\fR method.
.IP "3." 4
You must define a form field called 'destination' that tells
AuthCookie where to redirect the request after successfully logging
in.  Typically this value is obtained from \f(CW\*(C`$r\->prev\->uri\*(C'\fR.
See the login.pl script in t/eg/.
.PP
In addition, you might want your login page to be able to tell why
the user is being asked to log in.  In other words, if the user sent
bad credentials, then it might be useful to display an error message
saying that the given username or password are invalid.  Also, it
might be useful to determine the difference between a user that sent
an invalid auth cookie, and a user that sent no auth cookie at all.  To
cope with these situations, \fBAuthCookie\fR will set
\&\f(CW\*(C`$r\->subprocess_env('AuthCookieReason')\*(C'\fR to one of the following values.
.IP "\fIno_cookie\fR" 4
.IX Item "no_cookie"
The user presented no cookie at all.  Typically this means the user is
trying to log in for the first time.
.IP "\fIbad_cookie\fR" 4
.IX Item "bad_cookie"
The cookie the user presented is invalid.  Typically this means that the user
is not allowed access to the given page.
.IP "\fIbad_credentials\fR" 4
.IX Item "bad_credentials"
The user tried to log in, but the credentials that were passed are invalid.
.PP
You can examine this value in your login form by examining
\&\f(CW\*(C`$r\->prev\->subprocess_env('AuthCookieReason')\*(C'\fR (because it's
a sub\-request).
.PP
Of course, if you want to give more specific information about why
access failed when a cookie is present, your \f(CW\*(C`authen_ses_key()\*(C'\fR
method can set arbitrary entries in \f(CW\*(C`$r\->subprocess_env\*(C'\fR.
.SH "THE LOGOUT SCRIPT"
.IX Header "THE LOGOUT SCRIPT"
If you want to let users log themselves out (something that can't be
done using Basic Auth), you need to create a logout script.  For an example,
see t/htdocs/docs/logout.pl.  Logout scripts may want to take advantage of
AuthCookie's \f(CW\*(C`logout()\*(C'\fR method, which will set the proper cookie headers in
order to clear the user's cookie.  This usually looks like
\&\f(CW\*(C`$r\->auth_type\->logout($r);\*(C'\fR.
.PP
Note that if you don't necessarily trust your users, you can't count
on cookie deletion for logging out.  You'll have to expire some
server-side login information too.  AuthCookie doesn't do this for
you, you have to handle it yourself.
.SH "ABOUT SESSION KEYS"
.IX Header "ABOUT SESSION KEYS"
Unlike the sample AuthCookieHandler, you have you verify the user's
login and password in \f(CW\*(C`authen_cred()\*(C'\fR, then you do something
like:
.PP
.Vb 2
\&    my $date = localtime;
\&    my $ses_key = MD5->hexhash(join(';', $date, $PID, $PAC));
.Ve
.PP
save \f(CW$ses_key\fR along with the user's login, and return \f(CW$ses_key\fR.
.PP
Now \f(CW\*(C`authen_ses_key()\*(C'\fR looks up the \f(CW$ses_key\fR passed to it and
returns the saved login.  I use Oracle to store the session key and
retrieve it later, see the ToDo section below for some other ideas.
.SH "KNOWN LIMITATIONS"
.IX Header "KNOWN LIMITATIONS"
If the first unauthenticated request is a \s-1POST\s0, it will be changed to
a \s-1GET\s0 after the user fills out the login forms, and POSTed data will
be lost.
.Sh "\s-1TO\s0 \s-1DO\s0"
.IX Subsection "TO DO"
.IP "\(bu" 4
There ought to be a way to solve the \s-1POST\s0 problem in the \s-1LIMITATIONS\s0
section.  It involves being able to re-insert the POSTed content into
the request stream after the user authenticates.
.Sp
It might be nice if the logout method could accept some parameters
that could make it easy to redirect the user to another \s-1URI\s0, or
whatever.  I'd have to think about the options needed before I
implement anything, though.
.SH "CVS REVISION"
.IX Header "CVS REVISION"
$Id$
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Schout <mschout@cpan.org>
.PP
Originally written by Eric Bartley <bartley@purdue.edu>
.PP
versions 2.x were written by Ken Williams <ken@forum.swarthmore.edu>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000 Ken Williams. All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIperl\fR\|(1), \fImod_perl\fR\|(1), \fIApache\fR\|(1).
